// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common/message_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct MessageState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var read: Bool = false

  var delivered: Bool = false

  var edited: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Money {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The three-letter currency code defined in ISO 4217.
  var currencyCode: String = String()

  /// The whole units of the amount.
  /// For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
  var units: Int64 = 0

  /// Number of nano (10^-9) units of the amount.
  /// The value must be between -999,999,999 and +999,999,999 inclusive.
  /// If `units` is positive, `nanos` must be positive or zero.
  /// If `units` is zero, `nanos` can be positive, zero, or negative.
  /// If `units` is negative, `nanos` must be negative or zero.
  /// For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
  var nanos: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MoneyStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: MoneyStatusEnum = .moneyStatusUnknown

  var message: String = String()

  var updated: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MessageMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var created: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TextMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AudioMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var duration: Int64 = 0

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var duration: Int64 = 0

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PhotoMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var width: Int32 = 0

  var height: Int32 = 0

  var preview: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FileMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LocationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lat: Double = 0

  var lon: Double = 0

  var desc: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ContactMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var phone: String = String()

  var firstname: String = String()

  var lastname: String = String()

  var userID: String = String()

  var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  mutating func clearPhoto() {self._photo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _photo: Photo? = nil
}

struct MoneyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var money: Money {
    get {return _money ?? Money()}
    set {_money = newValue}
  }
  /// Returns true if `money` has been explicitly set.
  var hasMoney: Bool {return self._money != nil}
  /// Clears the value of `money`. Subsequent reads from it will return its default value.
  mutating func clearMoney() {self._money = nil}

  var status: MoneyStatus {
    get {return _status ?? MoneyStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Uniq transaction ID for this money transfer.
  /// Field can be empty if integration with third party is in backend,
  /// in that case transaction_id will be delivered as "update". In case
  /// integration is in client side then client should send it
  var transactionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _money: Money? = nil
  fileprivate var _status: MoneyStatus? = nil
}

struct VideoMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var duration: Int64 = 0

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var width: Int32 = 0

  var height: Int32 = 0

  var thumbFileID: String = String()

  var thumbPreview: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Receiver {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var chatID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var receiver: Receiver {
    get {return _storage._receiver ?? Receiver()}
    set {_uniqueStorage()._receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  var hasReceiver: Bool {return _storage._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  mutating func clearReceiver() {_uniqueStorage()._receiver = nil}

  var sender: Sender {
    get {return _storage._sender ?? Sender()}
    set {_uniqueStorage()._sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  var hasSender: Bool {return _storage._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  mutating func clearSender() {_uniqueStorage()._sender = nil}

  var state: MessageState {
    get {return _storage._state ?? MessageState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {_uniqueStorage()._state = nil}

  var meta: MessageMeta {
    get {return _storage._meta ?? MessageMeta()}
    set {_uniqueStorage()._meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  var hasMeta: Bool {return _storage._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  mutating func clearMeta() {_uniqueStorage()._meta = nil}

  var chatType: ChatTypeEnum {
    get {return _storage._chatType}
    set {_uniqueStorage()._chatType = newValue}
  }

  var seqNumber: UInt64 {
    get {return _storage._seqNumber}
    set {_uniqueStorage()._seqNumber = newValue}
  }

  var type: MessageTypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var text: String {
    get {return _storage._text}
    set {_uniqueStorage()._text = newValue}
  }

  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var audio: AudioMessage {
    get {
      if case .audio(let v)? = _storage._content {return v}
      return AudioMessage()
    }
    set {_uniqueStorage()._content = .audio(newValue)}
  }

  var voice: VoiceMessage {
    get {
      if case .voice(let v)? = _storage._content {return v}
      return VoiceMessage()
    }
    set {_uniqueStorage()._content = .voice(newValue)}
  }

  var photo: PhotoMessage {
    get {
      if case .photo(let v)? = _storage._content {return v}
      return PhotoMessage()
    }
    set {_uniqueStorage()._content = .photo(newValue)}
  }

  var video: VideoMessage {
    get {
      if case .video(let v)? = _storage._content {return v}
      return VideoMessage()
    }
    set {_uniqueStorage()._content = .video(newValue)}
  }

  var money: MoneyMessage {
    get {
      if case .money(let v)? = _storage._content {return v}
      return MoneyMessage()
    }
    set {_uniqueStorage()._content = .money(newValue)}
  }

  var location: LocationMessage {
    get {
      if case .location(let v)? = _storage._content {return v}
      return LocationMessage()
    }
    set {_uniqueStorage()._content = .location(newValue)}
  }

  var file: FileMessage {
    get {
      if case .file(let v)? = _storage._content {return v}
      return FileMessage()
    }
    set {_uniqueStorage()._content = .file(newValue)}
  }

  var contact: ContactMessage {
    get {
      if case .contact(let v)? = _storage._content {return v}
      return ContactMessage()
    }
    set {_uniqueStorage()._content = .contact(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case audio(AudioMessage)
    case voice(VoiceMessage)
    case photo(PhotoMessage)
    case video(VideoMessage)
    case money(MoneyMessage)
    case location(LocationMessage)
    case file(FileMessage)
    case contact(ContactMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Message.OneOf_Content, rhs: Message.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.voice, .voice): return {
        guard case .voice(let l) = lhs, case .voice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.photo, .photo): return {
        guard case .photo(let l) = lhs, case .photo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.video, .video): return {
        guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.money, .money): return {
        guard case .money(let l) = lhs, case .money(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contact, .contact): return {
        guard case .contact(let l) = lhs, case .contact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents messages range based on sequence number 
/// of message
struct MessagesRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only required property. For example if required to mark
  /// only one message as "read" or "delivered" only this value 
  /// can be provided
  var maxSeqNumber: UInt64 = 0

  /// Minimal seq number of messages range. If not provided then
  /// it's requal to "max_seq_number"
  var minSeqNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension MessageState: @unchecked Sendable {}
extension Money: @unchecked Sendable {}
extension MoneyStatus: @unchecked Sendable {}
extension MessageMeta: @unchecked Sendable {}
extension TextMessage: @unchecked Sendable {}
extension AudioMessage: @unchecked Sendable {}
extension VoiceMessage: @unchecked Sendable {}
extension PhotoMessage: @unchecked Sendable {}
extension FileMessage: @unchecked Sendable {}
extension LocationMessage: @unchecked Sendable {}
extension ContactMessage: @unchecked Sendable {}
extension MoneyMessage: @unchecked Sendable {}
extension VideoMessage: @unchecked Sendable {}
extension Sender: @unchecked Sendable {}
extension Receiver: @unchecked Sendable {}
extension Message: @unchecked Sendable {}
extension Message.OneOf_Content: @unchecked Sendable {}
extension MessagesRange: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MessageState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessageState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "read"),
    2: .same(proto: "delivered"),
    3: .same(proto: "edited"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.read) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.delivered) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.edited) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.read != false {
      try visitor.visitSingularBoolField(value: self.read, fieldNumber: 1)
    }
    if self.delivered != false {
      try visitor.visitSingularBoolField(value: self.delivered, fieldNumber: 2)
    }
    if self.edited != 0 {
      try visitor.visitSingularInt64Field(value: self.edited, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessageState, rhs: MessageState) -> Bool {
    if lhs.read != rhs.read {return false}
    if lhs.delivered != rhs.delivered {return false}
    if lhs.edited != rhs.edited {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Money: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Money"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "currency_code"),
    2: .same(proto: "units"),
    3: .same(proto: "nanos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.units) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.nanos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 1)
    }
    if self.units != 0 {
      try visitor.visitSingularInt64Field(value: self.units, fieldNumber: 2)
    }
    if self.nanos != 0 {
      try visitor.visitSingularInt32Field(value: self.nanos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Money, rhs: Money) -> Bool {
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.units != rhs.units {return false}
    if lhs.nanos != rhs.nanos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MoneyStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MoneyStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
    3: .same(proto: "updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.updated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .moneyStatusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.updated != 0 {
      try visitor.visitSingularInt64Field(value: self.updated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MoneyStatus, rhs: MoneyStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.updated != rhs.updated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessageMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "created"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.created) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.created != 0 {
      try visitor.visitSingularInt64Field(value: self.created, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessageMeta, rhs: MessageMeta) -> Bool {
    if lhs.created != rhs.created {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TextMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TextMessage, rhs: TextMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AudioMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AudioMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .same(proto: "duration"),
    3: .standard(proto: "file_size"),
    4: .standard(proto: "mime_type"),
    5: .standard(proto: "file_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 2)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AudioMessage, rhs: AudioMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .same(proto: "duration"),
    3: .standard(proto: "file_size"),
    4: .standard(proto: "mime_type"),
    5: .standard(proto: "file_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 2)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceMessage, rhs: VoiceMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PhotoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PhotoMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .standard(proto: "file_size"),
    3: .standard(proto: "mime_type"),
    4: .standard(proto: "file_name"),
    5: .same(proto: "width"),
    6: .same(proto: "height"),
    8: .same(proto: "preview"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.preview) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 4)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 6)
    }
    if !self.preview.isEmpty {
      try visitor.visitSingularBytesField(value: self.preview, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PhotoMessage, rhs: PhotoMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.preview != rhs.preview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FileMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .standard(proto: "file_size"),
    3: .standard(proto: "mime_type"),
    4: .standard(proto: "file_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FileMessage, rhs: FileMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LocationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LocationMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lon"),
    3: .same(proto: "desc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lon) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lon != 0 {
      try visitor.visitSingularDoubleField(value: self.lon, fieldNumber: 2)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LocationMessage, rhs: LocationMessage) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ContactMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ContactMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "firstname"),
    3: .same(proto: "lastname"),
    4: .standard(proto: "user_id"),
    5: .same(proto: "photo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.firstname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.firstname.isEmpty {
      try visitor.visitSingularStringField(value: self.firstname, fieldNumber: 2)
    }
    if !self.lastname.isEmpty {
      try visitor.visitSingularStringField(value: self.lastname, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ContactMessage, rhs: ContactMessage) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.firstname != rhs.firstname {return false}
    if lhs.lastname != rhs.lastname {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._photo != rhs._photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MoneyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MoneyMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "money"),
    2: .same(proto: "status"),
    3: .standard(proto: "transaction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._money) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._money {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MoneyMessage, rhs: MoneyMessage) -> Bool {
    if lhs._money != rhs._money {return false}
    if lhs._status != rhs._status {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VideoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VideoMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .same(proto: "duration"),
    3: .standard(proto: "file_size"),
    4: .standard(proto: "mime_type"),
    5: .standard(proto: "file_name"),
    6: .same(proto: "width"),
    7: .same(proto: "height"),
    8: .standard(proto: "thumb_file_id"),
    9: .standard(proto: "thumb_preview"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.thumbFileID) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.thumbPreview) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 2)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 5)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 6)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 7)
    }
    if !self.thumbFileID.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbFileID, fieldNumber: 8)
    }
    if !self.thumbPreview.isEmpty {
      try visitor.visitSingularBytesField(value: self.thumbPreview, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VideoMessage, rhs: VideoMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.thumbFileID != rhs.thumbFileID {return false}
    if lhs.thumbPreview != rhs.thumbPreview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Sender"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sender, rhs: Sender) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Receiver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Receiver"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "chat_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Receiver, rhs: Receiver) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "receiver"),
    3: .same(proto: "sender"),
    4: .same(proto: "state"),
    5: .same(proto: "meta"),
    6: .standard(proto: "chat_type"),
    7: .standard(proto: "seq_number"),
    8: .same(proto: "type"),
    9: .same(proto: "text"),
    10: .same(proto: "audio"),
    11: .same(proto: "voice"),
    12: .same(proto: "photo"),
    13: .same(proto: "video"),
    14: .same(proto: "money"),
    15: .same(proto: "location"),
    16: .same(proto: "file"),
    17: .same(proto: "contact"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _receiver: Receiver? = nil
    var _sender: Sender? = nil
    var _state: MessageState? = nil
    var _meta: MessageMeta? = nil
    var _chatType: ChatTypeEnum = .peerToPeer
    var _seqNumber: UInt64 = 0
    var _type: MessageTypeEnum = .text
    var _text: String = String()
    var _content: Message.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _receiver = source._receiver
      _sender = source._sender
      _state = source._state
      _meta = source._meta
      _chatType = source._chatType
      _seqNumber = source._seqNumber
      _type = source._type
      _text = source._text
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._receiver) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sender) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._state) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._meta) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._chatType) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._seqNumber) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 10: try {
          var v: AudioMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .audio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .audio(v)
          }
        }()
        case 11: try {
          var v: VoiceMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .voice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .voice(v)
          }
        }()
        case 12: try {
          var v: PhotoMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .photo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .photo(v)
          }
        }()
        case 13: try {
          var v: VideoMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .video(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .video(v)
          }
        }()
        case 14: try {
          var v: MoneyMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .money(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .money(v)
          }
        }()
        case 15: try {
          var v: LocationMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .location(v)
          }
        }()
        case 16: try {
          var v: FileMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .file(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .file(v)
          }
        }()
        case 17: try {
          var v: ContactMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .contact(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .contact(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._receiver {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sender {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._meta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._chatType != .peerToPeer {
        try visitor.visitSingularEnumField(value: _storage._chatType, fieldNumber: 6)
      }
      if _storage._seqNumber != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._seqNumber, fieldNumber: 7)
      }
      if _storage._type != .text {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 8)
      }
      if !_storage._text.isEmpty {
        try visitor.visitSingularStringField(value: _storage._text, fieldNumber: 9)
      }
      switch _storage._content {
      case .audio?: try {
        guard case .audio(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .voice?: try {
        guard case .voice(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .photo?: try {
        guard case .photo(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .video?: try {
        guard case .video(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .money?: try {
        guard case .money(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .location?: try {
        guard case .location(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .file?: try {
        guard case .file(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .contact?: try {
        guard case .contact(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Message, rhs: Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._chatType != rhs_storage._chatType {return false}
        if _storage._seqNumber != rhs_storage._seqNumber {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessagesRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessagesRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "max_seq_number"),
    3: .standard(proto: "min_seq_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maxSeqNumber) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.minSeqNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxSeqNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxSeqNumber, fieldNumber: 2)
    }
    if self.minSeqNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.minSeqNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessagesRange, rhs: MessagesRange) -> Bool {
    if lhs.maxSeqNumber != rhs.maxSeqNumber {return false}
    if lhs.minSeqNumber != rhs.minSeqNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
