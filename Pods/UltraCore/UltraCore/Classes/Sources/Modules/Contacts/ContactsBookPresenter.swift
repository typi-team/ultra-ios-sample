//
//  ContactsBookPresenter.swift
//  Pods
//
//  Created by Slam on 4/21/23.
//  Copyright (c) 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//
import RxSwift
import RealmSwift
import Foundation

final class ContactsBookPresenter: BasePresenter {
    
    // MARK: - Public properties -

    lazy var contacts: BehaviorSubject<[Contact]> = .init(value: [])

    // MARK: - Private properties -
    
    fileprivate let contactsCallback: ContactsCallback
    fileprivate let openConversationCallback: UserIDCallback

    fileprivate let mediaUtils = MediaUtils()
    fileprivate let appStore: AppSettingsStore
    fileprivate let contactsRepository: ContactsRepository
    fileprivate unowned let view: ContactsBookViewInterface
    fileprivate let wireframe: ContactsBookWireframeInterface
    fileprivate let contactImageDownloadInteractor: UseCase<Contact, Void>
    fileprivate let bookContacts: UseCase<Void, ContactsBookInteractor.Contacts>
    fileprivate let syncContact: UseCase<ContactsImportRequest, ContactImportResponse>
    
    // MARK: - Lifecycle -

    init(appStore: AppSettingsStore,
         view: ContactsBookViewInterface,
         contactsRepository: ContactsRepository,
         wireframe: ContactsBookWireframeInterface,
         contactsCallback: @escaping ContactsCallback,
         openConversationCallback:@escaping UserIDCallback,
         contactImageDownloadInteractor: UseCase<Contact, Void>,
         syncContact: UseCase<ContactsImportRequest, ContactImportResponse>,
         bookContacts: UseCase<Void, ContactsBookInteractor.Contacts>) {
        self.view = view
        self.appStore = appStore
        self.wireframe = wireframe
        self.syncContact = syncContact
        self.bookContacts = bookContacts
        self.contactsCallback = contactsCallback
        self.contactsRepository = contactsRepository
        self.openConversationCallback = openConversationCallback
        self.contactImageDownloadInteractor = contactImageDownloadInteractor
    }
}

// MARK: - Extensions -

extension ContactsBookPresenter: ContactsBookPresenterInterface {
    func openConversation(with contact: ContactDisplayable) {
        
        self.wireframe.dissmiss(completion: {[weak self] in
            guard let `self` = self else { return }
            self.openConversationCallback(Contact.with({
                $0.phone = contact.phone
                $0.firstname = contact.displaName
            }))
        })
    }
    
    func initial() {
        self.bookContacts
            .executeSingle(params: ())
            .flatMap({ [weak self] result -> Single<ContactImportResponse> in
                guard let `self` = self else { throw NSError.selfIsNill }
                if result.contacts.isEmpty {
                    return Single.just(ContactImportResponse())
                }
                var request = ContactsImportRequest()
                request.contacts = result.contacts
                return self.syncContact.executeSingle(params: request)
            })
            .map({ $0.contacts })
            .do(onSuccess: { [weak self] response in
                guard let `self` = self else { return }
                self.contactsCallback(response)
            })
            .do(onSuccess: {[weak self] contacts in
                guard let `self` = self else { return }
                self.contacts.on(.next(contacts))
            })
            .asObservable()
            .flatMap({ contacts -> Observable<[Contact]> in
                Observable.from(contacts)
                    .flatMap({ [weak self] contact -> Single in
                        guard let `self` = self else { throw NSError.selfIsNill }
                        return self.contactImageDownloadInteractor.executeSingle(params: contact)
                    })
                    .map({ contacts })
            })
            .do(onNext: {[weak self] contacts in
                guard let `self` = self else { return }
                self.contacts.on(.next(contacts))
            })
                
            .subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))
            .observe(on: MainScheduler.instance)
            .subscribe(onNext: { contacts in PP.info("Contacts \(contacts.count)pcs saved on db") })
            .disposed(by: self.disposeBag)
    }
}
extension Contact: IContact {}
